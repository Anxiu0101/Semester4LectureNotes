## 本节导读

- Non Preemptive Priority Scheduling using HRN 使用 HRN 的非抢占式优先级调度
- Preemptive Scheduling using RR 使用 RR 的抢占式调度
- Analysis of RR with different quantum lengths 不同量子长度的RR分析
- Multilevel Feedback Queues 多级反馈队列
- Case Study – Traditional Unix Scheduler and Fair Share Scheduler Concept 案例研究——传统的 Unix 调度器和公平共享调度器概念

相应时间 $Response Ratio = (W + S)/S$

抢占式调度 ==Preemptive Scheduling==  
在多任务系统中用作调度基础的一种常见算法类型称为==轮询 Round Robin==。 选择轮循是因为它为所有进程提供了**良好的响应时间** ==good response time to all processes==，这对于在多任务系统中实现令人满意的交互性能很重要。

抢占式调度 Round Robin 是FCFS的一个抢占式版本。每个进程轮流执行，直到它的时间量子过期，强制进行任务上下文切换。时间量子(quantum)可以被改变，以便为特定的工作负载提供最佳结果。

就是在每个进程都运行n个单位的CPU时间，轮流执行直至所有任务完成，每个进程被完成时从其中移出


![](Pasted%20image%2020220309142120.png)

在选择轮回调度的量子时，很难适合所有的工作。如果CPU的平均爆发时间有很大的偏差，那么可以采用多级队列的方法，并进行反馈。这种自适应的方法从长远来看减少了任务切换的开销。
一个进程最初被提交到最高级别的最高优先级队列中，在那里它可以获得良好的响应时间。如果它的行为随着时间的推移表明它的计算要求很高，那么它可以被降级到一个较低的优先级队列中，由于更合适的CPU量子长度，它将产生较少的任务切换，但该队列可能收到较少的 的关注。


优先级调度 Priority Scheduling 
Round Robin 不允许用户告诉系统哪些任务比其他任务更重要。 在优先级调度系统中，进程被分配一个数值，表示它们的调度优先级。 用户可以指示分配给任务的优先级高于其他任务。
调度程序总是首先选择具有最高优先级的进程。
这是一个易于实施的方案，但需要一种计算优先级的方法，以便较低优先级的任务不会饿死。

案例研究——传统的 Unix 调度器
旨在为单个用户在单个处理器上支持分时多任务交互环境。
最初不是为实时处理要求（在时间限制内调度任务）、多用户或对称多处理而设计的。
大约自 2003 年以来，现代 Unix 实现已经过修改以满足这些要求。

为交互式用户任务提供良好的响应时间，同时确保低优先级的后台任务不会饿死，并且可以快速完成高优先级的系统任务。
多级反馈方法
使用轮询服务的优先队列。
优先级是一个介于 0 和 127 之间的值。数字越小，优先级越高。 优先级 0 到 49 用于内核进程，优先级从 50 到 127 用于用户进程。

系统范围内所有进程的优先级是根据它们的执行历史和用于将进程置于优先级带中的基本优先级以一秒的间隔计算的。
$$Pj(i) = Basej + CPUj(i)/2 + nicej$$  
i 表示第 i 个感兴趣的区间，j 表示进程 id。 如果仍在使用 CPU，则用户进程会在 1 秒后被抢占，然后选择优先级最高的任务。


## Deal with multiple user

> How to deal with multiple users?

在多用户多任务系统中，每个用户可能正在运行他们自己任务的集合。 一个用户或应用程序运行的进程可能比另一个用户或应用程序运行的进程少得多。 到目前为止，我们的调度算法只关注在整个进程集之间实现公平分配，而不是在不同用户或不同应用程序之间实现 CPU 时间的公平分配。

> Fair-Share Scheduling




